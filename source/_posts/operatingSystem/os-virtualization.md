---
title: OS-进程与虚拟CPU
date: 2021-06-15 21:54:20
tags:
categories: 操作系统
---
- [进程与虚拟CPU](#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E8%99%9A%E6%8B%9FCPU)
    - [进程切换](#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2)
        - [1.中断](#1-%E4%B8%AD%E6%96%AD)
        - [2.内中断-系统调用](#2-%E5%86%85%E4%B8%AD%E6%96%AD-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)
        - [3.外中断-时钟中断](#3-%E5%A4%96%E4%B8%AD%E6%96%AD-%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD)
        - [4.上下文切换](#4-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2)
    - [进程调度策略(MLFQ)](#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5-MLFQ)
        - [1.两种基本算法](#1-%E4%B8%A4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95)
        - [2.多级反馈队列(主流)](#2-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97-%E4%B8%BB%E6%B5%81)
        - [3.优化下MLFQ](#3-%E4%BC%98%E5%8C%96%E4%B8%8BMLFQ)
        - [4.MLFQ的进阶](#4-MLFQ%E7%9A%84%E8%BF%9B%E9%98%B6)
    - [参考资料](#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)

# 进程与虚拟CPU
操作系统中最重要的一个概念就是进程，最重要的特性就是并发性。
进程是对正在运行中的程序的一个抽象，也可理解为**PCB+程序代码+运行时数据**
并发性是将**一个cpu变成多个虚拟的cpu**，从而让进程能并发执行，后面我们用虚拟CPU来表示这个功能。

实现虚拟CPU的技术，主要靠几种底层机制(时钟中断、软中断、上下文切换等)以及一种上层策略(进程调度策略)来实现。
首先我们了解下进程的状态(实际不止3种)：
![](Images\proc_statue.png)
这张图里红色的内容就是我们这次要唠叨的重点了。

### 进程切换
对汇编、计组原理有了解的同学可能知道，指令在执行的过程中，CPU只会干“PC=PC+1”这么一个过程，因此如果一个进程一直不让出CPU，那它就可以一直执行下去，那么进程是如何切换的呢？

##### 1.中断
计算机依靠中断来实现从用户进程到内核的切换，中断在计算机里的重要性无可替代，简单来说**中断就是打断运行中的cpu，并告诉cpu先去处理其他紧急的事情。**
如果对中断继续研究下去，就又产生3个问题：
1.中断是如何打断cpu的
2.cpu该如何处理这个中断
3.处理完中断之后，cpu怎么回到原点继续执行？

回答这些问题，需要计算机组成原理的相关知识，我们简单了解下：
1.cpu在执行完每条指令之后，都会有一个**中断周期**来判断是否有中断信号需要处理，如果有中断，会有硬件来实现转去执行中断服务程序(这个过程也叫**中断隐指令**)
2.操作系统在启动的时候会设置一个**中断向量表**，这个中断向量表用来**存放中断服务程序的入口地址**。然后**硬件会根据中断向量寻址中断服务程序**。
3.硬件(也就是前面说的中断隐指令)会**关中断、保存PC寄存器、对中断服务程序寻址**，而中断服务程序则会保存现场(即保存寄存器等数据)，执行中断程序，回复现场等等，通过硬件和软件的配合，就可以执行完中断之后，又回到原点。

关于中断的原理介绍就到这里了，下面再介绍下中断的分类：
1. 内中断：系统调用(trap)、各种异常(如缺页、地址越界)等内部事件。
2. 外中断：由外部设备产生的事件，如磁盘完成数据准备，时钟设备的一个时钟周期已到，等等。

##### 2.内中断-系统调用
为了能够顺利进入到内核，我们先介绍**主动进入内核**的办法*-系统调用。

之前在[c/c++反汇编](https://liji53.github.io/2021/06/10/compileAssemblyLink/disassembly/)已经对应用层的系统调用汇编代码做过一波分析了。
现在我们讲下后面的流程：通过syscall指令使执行逻辑从**用户态切换到内核态**，在进入到内核态之后，cpu会从指定的寄存器中读取内核代码的入口地址，进入内核之后自然就可以**通过读取rax寄存器知道系统调用号**，再根据**system call table**转到对应的处理函数中。

如果对syscall指令具体干了什么事情感兴趣，可以到官网上找相应架构的指令集。比方[intel](https://www.intel.cn/content/www/cn/zh/developer/articles/technical/intel-sdm.html)，从[下载链接](https://cdrdv2.intel.com/v1/dl/getContent/671241)这个下载链接中就有对syscall的描述。

最后我们再来理解下这个流程：
![](Images\set_trap_table.png)

##### 3.外中断-时钟中断
而另一种**被动进入内核**的方法就是时钟中断，一旦时钟中断产生，cpu就会自动运行到内核态。
依靠这个时钟中断，我们就能把进程**按照时间段进行切分**(进程运行的基本时间单位，**一个时间片的范围是几毫秒到几百毫秒**)：
一个进程运行一段时间，然后硬件定时器发生一个时钟中断，进程就被动的进入内核，内核再根据调度策略决定下面运行哪个进程，如此反复。
看下来自[xv6](https://github.com/mit-pdos/xv6-riscv.git)(一个用于教学的操作系统)对时钟中断的初始化处理：
```c
timerinit()
{
  ...
  // prepare information in scratch[] for timervec.
  // scratch[0..2] : space for timervec to save registers.
  // scratch[3] : address of CLINT MTIMECMP register.
  // scratch[4] : desired interval (in cycles) between timer interrupts.
  uint64 *scratch = &timer_scratch[id][0];
  scratch[3] = CLINT_MTIMECMP(id);
  scratch[4] = interval;
  // 把定时器的参数写入到mscratch寄存器，timervec中需要读取对应的参数，并设置定时器。
  w_mscratch((uint64)scratch);
  // set the machine-mode trap handler.
  //给硬件设置对应的处理时钟中断的中断服务程序地址。
  w_mtvec((uint64)timervec);
  // enable machine-mode interrupts.
  w_mstatus(r_mstatus() | MSTATUS_MIE);
  // enable machine-mode timer interrupts.
  w_mie(r_mie() | MIE_MTIE);
}
```
最后，我们看下通过时钟中断来实现进程切换的流程图：
![](Images\interrupt_table.png)

##### 4.上下文切换
从前面中断的原理中，我们已经初步了解了中断的上下文切换，也了解了硬件在处理中断时所起到的作用（中断隐指令）。
但除了上面说的中断上下文切换，还分进程上下文切换和线程上下文切换。它们的区别主要来切换时需要保存的资源，比如进程有虚拟内存、全局变量等资源，线程有线程栈的资源。
因此对于进程上下文切换来说，除了保存堆栈信息以外，还要保存内存等资源（其实也就是更新PCB），时间片耗尽就属于进程上下文切换。

最后我们看下[xv6](https://github.com/mit-pdos/xv6-riscv.git)中上下文切换的代码片段：
```c
.globl swtch
swtch:
    /// a0寄存器保存了c->context的地址
    sd ra, 0(a0)
    sd sp, 8(a0)
    sd s0, 16(a0)
    ...
    /// a1寄存器保存了p->context的地址
    ld ra, 0(a1)
    ld sp, 8(a1)
    ld s0, 16(a1)
    ...  
    ret

// Saved registers for kernel context switches.
// 上下文的结构体
struct context {
  uint64 ra;
  uint64 sp;
  // callee-saved
  uint64 s0;
  uint64 s1;
  ...
};
/// 参数1: 当前进程的上下文
/// 参数2: 切换进程的上下文
swtch(&c->context, &p->context);
```

### 进程调度策略(MLFQ)
在讲调度策略之前，我们需要先了解OS切换进程时根据什么来选择进程的。
两个核心指标是：
1. 周转时间： Tturnaround = Tcompletion − Tarrival
2. 响应时间： Tresponse = Tfirstrun − Tarrival
可能在其他地方，你还会看到cpu利用率、等待时间、吞吐量等其他指标，但这里我们不考虑。

##### 1.两种基本算法
**最短作业优先(Shortest Job First)**:
这是一种对平均周转时间最友好的算法，它的策略就是根据程序运行时间(最短优先)来决定运行哪个程序，但这种算法有几个问题：
1. OS并不知道进程的运行时长是多少
2. 响应时间长的进程，需要等最短作业的进程运行完，才响应，可能存在饿死现象

**轮询调度算法(Round Robin)**:
这种算法就是通过定时器进行时间切片，轮换的切换进程，每个进程都是平等的。这种算法拥有较好的响应时间与公平性。
但它最大的问题就是平均周转时间变长，每个进程都是最长运行时间

##### 2.多级反馈队列(主流)
这种算法就是结合了SJF和RR算法的优点，使程序有较好的周转时间和响应时间。

首先看下这个算法怎么结合SJF算法的：通过**对进程进行优先级分类**，根据反馈的结果(怎么反馈？可以自行先思考)把进程放到不同的优先级的队列中。
再看它怎么结合RR算法的：对于**同一优先级的程序，使用RR算法**，轮换运行进程，就可保证它们的响应时间
因此它的快照长这样：
![](Images\multi_level_feedback_queue.png)
因此，我们设置2条MLFQ的基本规则：
**一. 如果Ａ的优先级大于Ｂ的优先级，运行Ａ，不运行Ｂ
二. 如果Ａ的优先级等于Ｂ的优先级，轮转运行Ａ和Ｂ**

之前在讲SJF算法时，我们说过它存在一个问题即OS并不知道进程的运行时间是多长,如果不知道进程的运行时间，我们怎么对进程进行优先级分类呢？
其实OS会根据观察进程的行为，来动态调整它的优先级．比方如果进程一直占用CPU，OS就认为它的优先级低，而如果一个进程在用完时间片之前就放弃cpu则认为它是高优先级。-这也是为什么这个算法的名字中带feedback。

因此我们再得到MLFQ的2条基本规则：
**三. 进程第一次加载，把该进程放在最高优先级
四. 如果进程用完时间片则降低优先级；如果没用完就放弃cpu则保持当前优先级**

##### 3.优化下MLFQ
基于上面的MLFQ算法，我们思考下MLFQ这个算法还存在什么问题？
1. 存在饥饿现象，即如果有很多的高优先级进程，那么低优先级的进程很可能长时间得不到运行
2. 用户可以操控调度器，简单来说就是进程可以在时间片结束之前，假装放弃cpu，从而让进程一直保持在高优先级

我们来看怎么解决第一个问题，即MLFQ的又一条规则：
**五. 每过一段时间之后，将所有进程都放到最高优先级（重置）**

例子如图所示：
![](Images\reboot_prior.png)

下面我们再看如何解决第二个问题，这个问题的根源是时间片是固定的，因此用户进程只要计算出时间片的时长就能利用了，解决办法就是优化第四条规则：
**四. 给进程分配不固定的时间片，一旦进程用完时间片，就降低优先级。**
这也是为什么linux的时间片长度是几毫秒到几百毫秒了。

例子如图所示：
![](Images\time_allotment.png)

##### 4.MLFQ的进阶
如何让MLFQ工作更高效，更公平，这就需要根据环境调整它的参数，主要涉及到以下的参数：
1. 优先级队列的个数
2. 每个队列，分到的时间片长度
3. 多久时间重置进程优先级

这里仅给出《Operating Systems: Three Easy Pieces》提到的solaris系统的参数
1. 60个队列
2. 高优先级的进程分到的时间最短20ms，低优先级的进程时间片最长几百毫秒
3. 每隔1秒重置一次进程优先级

### 参考资料
书籍：
《Operating Systems: Three Easy Pieces》[线上书籍](https://pages.cs.wisc.edu/~remzi/OSTEP/) - 上文中用到的图片大多来自本书
《Modern Operating Systems》（第四版）
xv6代码：
https://github.com/mit-pdos/xv6-riscv.git
PS：
对于新手特别推荐阅读《Operating Systems: Three Easy Pieces》英文原版