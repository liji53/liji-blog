---
title: cryptography-公钥密码
date: 2021-09-20 18:40:41
tags:
categories: 密码学
---
# 公钥密码
公钥密码又叫非对称密码，在加密、数字签名、密钥交换的场景中，经常用到公钥密码，但这三个问题的解决方案不一定非要用公钥密码来解决。
比方DSA用于数字签名，DH用于密钥交换，因此在概念上，我们要对公钥密码以及常见的应用场景做区分。

### DH(Diffie-Hellman)算法
在密钥交换问题中，我们可以让加密通信的双方交换一些信息，然后根据这些信息，双方可以各自生成相同的密钥，但其他人无法生成相同的密钥。
DH并不能算是公钥密码（仅个人理解：因为双方都有各自的私钥，无法用于加密解密），仅能用于密钥交换这种场景

##### 离散对数
离散对数是在公钥密码系统中非常的重要，在DH算法和后面的RSA算法都是基于离散对数问题才能实现。
对于一个整数n、底数G（原根）、质数P，可以找到唯一的指数a, 则指数a称为离散对数。
它背后的数学原理，涉及到欧拉公式、群的概念等等，就不介绍了，但我们至少要知道下面这个公式。
**n = G^a mod P**
按照这个公式，我们可以轻松计算出n，但是反过来，仅知道n、G、P却很难计算出a，这就是安全性的基础。

##### DH密钥交换步骤
DH密钥交换的过程如图所示：
![](Images/dh_procedure.png)
看下第⑤步骤的公式
A计算的密钥 = (G\^B mod P)\^A mod P
B计算的密钥 = (G\^A mod P)\^B mod P
其实最终可以表示成
共享密钥 = G^(A*B) mod P

##### DHE算法
DH算法可以根据一端的私钥是否是静态的，以此分成2种实现：
1. static DH算法，已经被废弃
2. DHE算法

static DH算法一般是服务端的私钥固定，客户端的私钥动态生成，但这样做，攻击者可以根据历史的数据暴力破解出服务器的私钥，因此这种算法已经废弃。
而DHE算法指的是双方的私钥都是动态生成，这样每次会话的过程都是独立的，攻击者破解难度就很大了。
现实中，tls的密钥交换算法ECDHE 其实就是 DHE + ECC。

### RSA
RSA是目前主流的公钥算法，当前RSA的密钥长度一般在1024位以上。
##### 加解密过程
RSA的加密过程可以用下面的公式来表示：
**密文 = 明文\^E mod N**
RSA的解密过程可以用下面的公式来表示：
**明文 = 密文\^D mod N**
其中E和N的组合就是公钥，D就是私钥。
想要通过E和N来破解密文，这就回到了离散对数问题，这是非常困难的。

##### 密钥对的生成
E和D并不是随意的，两者必须有一种公式关系。否则上面的加解密机制是无法实现的。
密钥对的生成步骤如下：
1. 随机生成2个很大的质数p、q(至少512位以上)
2. 生成N = p*q
3. 生成L，L为p-1 和q-1的最小公倍数 （L只在生成过程中出现）
4. 随机生成E，E要同时符合 {1<E<L，E和L的最大公约数必须为1}
5. 生成D，D要同时符合{1<E<L, E*D mod L = 1}

如图所示：
![](Images/rsa_procedure.png)

##### RSA安全的基础
除了需要通过离散对数来保证RSA的安全，还需要基于以下1个数学难题来保证RSA的安全：
>质因数分解困难。由于N是公开，如果攻击者能通过N来计算出p、q，那么RSA就被破解了，幸好目前还没有有效的算法能对大整数进行质因数分解(一旦有了，RSA也就不能用了)

那能不能通过E和D的关系来计算出D呢？
E * D mod L = 1
要计算出D必须知道L，而L又通过p、q计算出来的，因此无法通过E来计算D

##### RSA的缺点
RSA虽然是用的最广泛的公钥算法之一，但RSA也存在缺点：
1. 生成密钥麻烦，在密钥对的生成过程中，需要随机找2个大质数，因此难以一次会话一次加密 （tls的密钥交换算法不首选RSA的原因之一）
2. 密钥长度问题，一般需要1024位以上，使得运算代价很高（在相同安全强度下，基于ECC的密钥长度比RSA要短很多）

### ECC
ECC相比RSA，可以用较短的密钥达到相同的安全程度，同时具有处理速度更快、传输带宽更少的优点。
##### ECC加密过程
ECC的数学原理比RSA要复杂得多，涉及到椭圆曲线方程、阿贝尔群、有限域椭圆曲线、曲线点的阶等等一系列的概念与数学原理。
这里好复杂，参考资料（可以先零散的看些中文文章，对基础概念有些了解之后，再看这篇英文，把知识点串联起来）：
https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc
密钥对生成过程如下：
1. 选择一种有限域椭圆曲线Ep，比方secp256k1的曲线为y^2 = x^3 + 7 (mod p) 其中p为一个很大的整数.
2. 选一个基点G（对于secp256k1，G点可以任意曲线点，因为cofactor=1）
3. 随机选择一个整数k， 这个k就是私钥，这里逆推k是很困难的。
4. 计算出公钥，P = k*G ，其中P也是曲线上的一个点。
![](Images/ecc_generator.png)

加密的过程如下：
1. 将明文编码为M(怎么编码的我还不清楚)，M也为曲线上一点，并选择一个随机数r，要求r < n（n为G的阶）
2. 计算出2段密文Cipher1 和Cipher2, 其实这两个密文，还是曲线上的2个点。
   >Cipher1 = M + rP
   >Cipher2 = rG

解密过程如下：
1. 明文编码M = Cipher1−k*Cipher2 = M + rQ − krG = M + rkG − krG = M
2. 将M解码即可

### 数字签名
在[对称密码]()中我们讲到了消息验证码这一种用于验证消息完整性的技术了，现在我们来了解下另一种可以验证消息完整性的技术，除了识别篡改，还能防止否认。
整体结构如图所示：
![](Images/digest_arch.png)

##### 数字签名的校验过程
数字签名分为生成数字签名的过程以及验证数字签名的过程，一般对消息的散列值进行签名。
如图所示：
![](Images/digest_arch.png)
它的核心思想就是利用没有私钥的人无法生成该私钥所生成的密文。

##### 对数字签名的攻击
数字签名虽然能识别数据的完整性，但却无法认证数据的所有人。
1. 如果有人将签名、公钥 替换成自己的签名、公钥，不管他怎么修改数据，都是合法的。这种攻击手段也叫中间人攻击。对于中间人攻击，需要证书来识别通信的对象是否合法。
2. 利用RSA加解密公式的一致性，比方有人诱导你帮他签名一段数据，你用私钥签名其实是在帮他解密了，过程如下：
签名 = 附件数据\^D mod N  （你以为这只是一段随意的数据）
     = 密文\^D mod N      （其实这是密文）
     = 解密后的消息       （你看到签名之后是一段乱码，以为签名成功了，其实这是混合加密过程中的对称密钥）
要防止这种情况发生，首先确保不要随便用自己的私钥给不清楚的消息签名，其次对于不同的场景要使用不同的密钥对，比方密钥交换和数字签名不要用一个密钥对。

### 参考资料
书籍：
《图解密码技术》
网上资料：
https://www.cnblogs.com/Kalafinaian/p/7392505.html
https://cryptobook.nakov.com/asymmetric-key-ciphers/elliptic-curve-cryptography-ecc

